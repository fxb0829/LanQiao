<!--
 * @Description: 
 * @Author: fengxb
 * @Date: 2022-02-16 17:35:53
 * @LastEditor: fengxb
 * @LastEditTime: 2022-02-16 17:49:34
-->

## 93 递归实现组合型枚举

题目描述：
> 从 $1∼n$ 这 n 个整数中随机选出 $m$ 个，输出所有可能的选择方案。</br>
> 输入两个整数 $n$,$m$ ,在同一行用空格隔开。</br>
> 按照从小到大的顺序输出所有方案，每行 $1$ 个。</br>
> 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</br>
> 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 $1 \; 3 \;5 \;7$ 排在 $1\; 3\; 6\; 8$ 前面）。</br>
> 数据范围：$n > 0$, $0 \leq m \leq n$, $n+(n−m) \leq 25$

样例：

```text
input:[5 3]
output:[
    1 2 3 
    1 2 4 
    1 2 5 
    1 3 4 
    1 3 5 
    1 4 5 
    2 3 4 
    2 3 5 
    2 4 5 
    3 4 5
]
```

### 思路及代码

C++代码：

```C++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int n,m;
vector<int> nums;
vector<vector<int>> ways;

void dfs(int u)
{
    //超出个数以及个数不够的情况
    if(nums.size() > m || nums.size() + (n-u+1) < m) return;
    if(u == n + 1)
    {
        ways.push_back(nums);
        return;
    }

    nums.push_back(u);  //选择当前的数
    dfs(u+1);
    //恢复现场
    nums.pop_back();
    dfs(u+1);           //不选择当前的数
}

int main()
{
    scanf("%d %d",&n,&m);
    dfs(1);

    //输出结果
    for(int i = 0; i < ways.size(); i++)
    {
        for(int j = 0; j < ways[i].size(); j++)
        {
            printf("%d ",ways[i][j]);
        }
        puts("");
    }
    return 0;
}

```