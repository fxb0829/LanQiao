<!--
 * @Description: 
 * @Author: fengxb
 * @Date: 2022-02-18 10:22:41
 * @LastEditor: fengxb
 * @LastEditTime: 2022-02-18 14:06:16
-->

## 95 费解的开关

题目描述：
> 你玩过“拉灯”游戏吗？25 盏灯排成一个 5×5 的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</br>
> 我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。

```text
下面这种状态:
10111
01101
10111
10000
11011
在改变了最左上角的灯的状态后将变成：
01111
11101
10111
10000
11011
再改变它正中间的灯后状态将变成：
01111
11001
11001
10100
11011
给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。
```

> 第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。  </br>
> 以下若干行数据分为 $n$ 组，每组数据有 5 行，每行 5 个字符。  </br>
> 每组数据描述了一个游戏的初始状态。</br>
> 各组数据间用一个空行分隔。</br>
> 一共输出 $n$ 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</br>
> 对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。</br>
> 数据范围：$0 < n \leq 500$

### 思路及代码

思路：

- 每一行开关的操作，完全被前一行的灯的亮灭状态决定。上面一个的灯是亮的，则当前的一定不能操作，上面一个灯是灭的，则当前一定要操作。
- 第一行的所有枚举情况有$2^5$，即可任意用0~31来表示一种方案。
- 如何查看每一位上是0还是1？比如查看第2位：m>>2&1，所以公式为：m>>k&1

C++代码：

```C++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6;
//存储数组
char g[N][N],backup[N][N];
//偏移量数组
int dx[5] = {-1,0,1,0,0},dy[5] = {0,1,0,-1,0};

void turn(int x,int y)
{
    for(int i = 0; i < 5; i++)
    {
        int a = x + dx[i],b = y + dy[i];
        //边界判断
        if(a < 0 || a >= 5 || b < 0 || b >= 5) continue;
        g[a][b] ^= 1; //二进制下只有最后一位不同，异或1就可以改变
    }
}

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        //读入棋盘（每次读取一个字符串）
        for(int i = 0; i < 5; i++) cin >> g[i];
        //定义结果（最大为6）
        int res = 10;
        //操作
        for(int op = 0; op < 32; op++)
        {
            //备份
            memcpy(backup,g,sizeof g);
            int step = 0;
            //枚举第一行
            for(int i = 0; i < 5; i++)
            {
                //判断第一行的位 判断下一行的位置是否需要操作，1不操作，0操作
                if(!(op >> i & 1))
                {
                    step++;
                    turn(0,i);
                }
            }
            //剩下的行
            for(int i = 0; i < 4; i++)
            {
                for(int j = 0; j < 5; j++)
                {
                    //当前的灯是灭的，那么下一行的当前位置肯定要操作
                    if(g[i][j] == '0')
                    {
                        step++;
                        turn(i+1,j);
                    }
                }
            }
            bool dark = false;
            //根据最后一行判断灯是否全亮
            for(int i = 0; i < 5; i++)
            {
                if(g[4][i] == '0')
                {
                    dark = true;
                    break;
                }
            }
            if(!dark) res = min(res,step);
            //还原
            memcpy(g,backup,sizeof g);
        }
        if(res > 6) res = -1;
        cout << res << endl;
    }
    
    return 0;
}
```
