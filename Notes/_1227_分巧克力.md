<!--
 * @Description: 
 * @Author: fengxb
 * @Date: 2022-02-20 15:37:34
 * @LastEditor: fengxb
 * @LastEditTime: 2022-02-20 15:53:43
-->

## 1227 分巧克力

题目链接：[分巧克力](https://www.acwing.com/problem/content/1229/)

题目描述：
> 儿童节那天有 $K$ 位小朋友到小明家做客。
>
> 小明拿出了珍藏的巧克力招待小朋友们。
>
> 小明一共有 $N$ 块巧克力，其中第 $i$ 块是 $H$<sub>$i$</sub> × $W$<sub>$i$</sub> 的方格组成的长方形。
>
> 为了公平起见，小明需要从这 $N$ 块巧克力中切出 $K$ 块巧克力分给小朋友们。
>
> 切出的巧克力需要满足：
>
> 1. 形状是正方形，边长是整数
> 2. 大小相同
>
> 例如一块 $6×5$ 的巧克力可以切出 $6$ 块 $2×2$ 的巧克力或者 $2$ 块 $3×3$ 的巧克力。
>
> 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？
>
> 输入：第一行包含两个整数 $N$ 和 $K$。以下 $N$ 行每行包含两个整数 $H$<sub>$i$</sub> 和 $W$<sub>$i$</sub>。输入保证每位小朋友至少能获得一块 $1×1$ 的巧克力。
>
> 输出：输出切出的正方形巧克力最大可能的边长。
>
> 数据范围：$1 \leq N$,$K \leq 10^5$, $1 \leq H$<sub>$i$</sub>,$W$<sub>$i$</sub> $\leq 10^5$

样例：

```text
input:[
    2 10
    6 5
    5 6
]
output:[2]
```

### 思路及代码

思路：

- 块数=[长/边长]*[宽/边长]，边长越大，得到的块数越少，当某个边长值$x$满足块数$k$时，那么小于边长$x$的情况是一定能切出$k$个的，所以此题可以使用二分的思想来查找。

C++代码：

```C++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n,k;
int h[N],w[N];

bool check(int mid)
{
    int res = 0;
    for(int i = 0; i < n; i++)
    {
        res += (h[i ]/mid) * (w[i]/mid);
        if(res >= k) return true;
    }
    return false;
}

int main()
{
    scanf("%d %d",&n,&k);
    for(int i = 0; i < n; i++) scanf("%d %d",&h[i],&w[i]);

    int l = 1,r = 1e5;
    while(l < r)
    {
        int mid = l + r +1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    printf("%d\n",r);

    return 0;
}
```