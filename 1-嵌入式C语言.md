# 1-嵌入式C语言
### 1 什么是gcc？
编译文件：将代码转换成机器可以识别的程序

```cpp
gcc -o 输出的文件名 输入文件名
```
---
### 2 C语言的编译过程
预处理--编译--汇编--链接

|预处理|.c文件-->.i文件|【gcc -E】|
| :-----: | :----- | :-----: |
|编译|.i文件(或者.c文件)-->.s文件|【gcc -S】|
|汇编|.s文件-->.o文件|【gcc -c】|
|链接|.o文件-->程序 |【gcc -o】|

---
### 3 常见的错误
（1）预处理错误：

描述：文件not find

解决：gcc -I 跟查头文件的目录

（2）编译错误：语法错误 

（3）链接错误：

原材料不够（undefined reference to 'xxx');

原材料多了（multiple definition of 'xxxxx');

---
### 4 预处理的使用
|#include|包含头文件|
| :-----: | ----- |
|#define|宏  替换，不进行语法检查<br>#define 宏名 宏体  加括号|
|#ifdef #else #endif|条件预编译|

```cpp
#inclue <stdio.h>
//方法一：在文件中定义ABC实现
#define ABC

int main()
{
    #ifdef ABC
    printf("====%s====\n",__FILE__);
    #endif
    printf("hello world!\n");
    return 0;
}

//方法二：在gcc的是否添加宏实现
gcc -DABC -o build test.c
```
（1）预定义宏

|*\_\_FUNCTION\_\_*|函数名|
| :-----: | :-----: |
|*\_\_LINE\_\_*|行号|
|\_\_FILE\_\_|文件名|

（2）宏展开下的#、##

|#|字符串化|#define ABC(x)  #x |
| :-----: | :-----: | ----- |
|##|连接符号|#define ABC(x) day##x|

```cpp
#define ABC(x) #x
#define DAY(x) myday##x

int mian()
{
    printf(ABC(ab\n)); //得到 "ab\n" --  "ab"
    int myday1 = 10;
    int myday2 = 20;
    printf("the day is %d\n",DAY(1));  //the day is 10
    return 0;
}
```
---
### 5 关键字
（1）杂项

|sizeof|编译器给我们查看内存空间容量的一个工具|
| :-----: | ----- |
|return|返回的概念|

（2）数据类型

|char|1Byte==8bits   1个字节|0\~255（无符号）|
| :-----: | ----- | ----- |
|int|整型常量|0\~65535（无符号）|
|long、short|特殊长度的限制| |
|unsigned、signed|有无符号|无符号：数据；<br>有符号：数字|
|float、double|浮点数据| |
|void|占位标志、声明标志| |

（3）自定义数据类型

|struct|结构体：元素之间的和|
| :-----: | ----- |
|union|共用体：公用起始地址的一段内存|
|enum|枚举：被命名的整型常数的集合（内容值逐步递增），其实跟define是一致的，只是便于程序员之间交流|
|typedef|数据类型的别名|

```cpp
//结构体
struct myabc{
    unsigned int a;
    unsigned int b;
    unsigend int c;
};
struct myabc mybuf;

//共用体
union myABC{
    char a;
    int b;
};
union myABC abc;

//枚举
enum Week{  //Week只是一个代名词，使用的时候直接调用里面的变量
    MOD=0,TUE=1,WED=2,
    THU,FRI,SAT,SUN
};
enum Week w;  //描述的是一个4位的整型（C语言中比较弱化）
printf("the w is %lu\n",sizeof(w)); //the w is 4

//类型别名
typedef int a;  a是一个int类型的外号
a mysize = 4;
```
---
### 6 类型描述符
对内存资源存放位置的限定

|auto|默认情况：分配的内存可读可写的区域；<br>在{...}中：栈空间|
| :-----: | ----- |
|register|限制变量定义在寄存器上的修饰符；<br>编译器会尽量的安排CPU的寄存器去存放，如果寄存器不足时，还是存放在存储器中|
|static|三个位置：函数内部的变量、全局的变量、修饰函数|
|const|常量的定义|
|extern|外部声明|
|volatile|告知编译器编译方法的关键字，不优化编译|

---
### 7 运算符
（1）位运算

|<<|左移：乘法\*2  二进制下的移位 末尾都是补0|
| :-----: | ----- |
|\>>|右移：除法/2  与符号变量有关 负数补1 正数补0|
|&|&：屏蔽的意思 <br>       int a = 0x1234;  <br>       a & 0xff00;    //屏蔽低8bit，取出高8bit<br>&：取出的意思<br>&：清零器|
||||：保留   A | 1 === 1；   A | 0 === A<br>|：设置为高电平<br>      a = a | (0x1<<5);  //设置第5位为高电平，其他位不变<br>&：设置为低电平<br>      a = a &(\~(0x1<<5)); //设置第5位为低电平，其他位不变|
|^|相同为0，不相同为1；完成两个数据之间的交换|
|\~|取反操作|

（2）内存访问符号

|( )|限制符|
| :-----: | ----- |
|\[ \] |内存访问的ID符号|
|{ }|函数体的限制符|
|\-> .|地址访问|
|&、\*|取地址|

---
### 8 指针
指针的大小：32位-4个字节   64位-8个字节

（1）指针+修饰符

|const|const char \*p：（字符串）p指向的内存空间内容只能读，不能修改<br>char \* const p：指针的指向不能修改，指向内存空间的内容可以修改<br>const char \* const p：指针指向不能变，且指向的内存空间内容不能变|
| :-----: | ----- |
|volatile|防止优化指向内存地址|
|typedef|将复杂的声明别名化|

```cpp
char *p = "hello world!\n";        //双引号字符串要理解为const char*
char buf[] = {"hello world!\n"};
char *p2 = buf;

printf("the one is %x\n",*p);
*p = 'a';                          //会发生段错误，segmentation fault   
*p2 = 'a';                         //不会发生错误，buf本身内容是可以变的
printf("the %s\n",p);
printf("the %s\n",p2); 
```
（2）指针+运算符

|+、-|int \*p = xxx;  \[0x12\]<br>p+1 得到不是\[0x13\]，而是\[0x12+1*(*sizeof(*\**p))\]<br>指针的加法、减法实际上是加减一个单位 ,单位大小为sizeof(p\[0\])|
| :-----: | ----- |
|++、--|地址p会更新地址，上面p+1只是查看，不会改变p的地址|
|\[  \]|地址内容的标签访问方式，跳跃式访问|

```cpp
int main()
{
    int a = 0x12345678;
    int b = 0x99991199;
    int  *p1 = &b;
    char *p2 = (char*)&b;
    
    //*(p1+1) == p1[1]
    printf("the p+1 is %x,%x\n",*(p1+1),p1[1]); //12345678 12345678
    printf("the p2+1 is %x\n",p2[1]); // 11

    return 0;
}
```
（3）多级指针

存放地址的地址空间。

看到二维指针需要想到是是一个线性关系，如下图：

![image](images/tLjS_mkzI7lsks5mIKlHRXSqG2rRfT144FkCcD0OUR0.png)

```cpp
int main(int argc,char **argv){
    int i = 0;
    for(;i < argc; i++){
        printf("the argv is %s\n",argv[i]);
    }
    return 0;
}

int main(int argc,char **argv){
    int i = 0;
    while(argv[i] != NULL){
        printf("the argv is %s\n",argv[i]);
        i++;
    }
    return 0;
}
```
---
### 9 数组
内存分配的一种形式。

#### （1）数组的定义及初始化
数组名是一个常量符号，一定不要放到等号左边。

空间赋值：按照标签逐一赋值（比较慢）

空间第一次赋值：空间定义时告知编译器进行初始化

```cpp
//逐一赋值
int arr[3];
arr[0] = 1;
arr[1] = 2;
arr[2] =3;

//空间初始化赋值
int nums[5] = {1,2,3,4,5};
//注意：数组空间的初始化和变量的初始化本质不同，尤其在嵌入式的裸机开发中，空间的初始化往往需要库函数的辅助

char buf[5] = {'a','b','c'};  //ok的
//buf当成普通内存来看，没有问题
//buf当成一个字符串来看，最后加上一个'\0'，字符串的重要属性，结尾一定有个'\0'
char buf[10] = "hello";   //ok的
buf = "world";            //错误的，修改标签是不行的
```
#### （2）字符
字符拷贝函数的原则：

内存空间和内存空间的逐一赋值的功能的一个封装体；

一旦空间中出现0这个特殊值，函数就即将结束。

字符空间：

ASCII码编码来解码的解空间 --->给人看

\\0作为结束标志

非字符空间：

数据采集0x00-0xff 8bit

```cpp
char buf[10];          //string
unsigned char buf[10]; //data
```
memcpy:

```cpp
usigned char buf[10];
unsigned char sensor_buf[100];
memcpy(buf,sensor_buf,10*sizeof(unsigned char));
```
#### （3）指针数组
数组中存放的是一堆的指针。

```cpp
char* a[100];
sizeof(a) = 100*4;
```
#### （4）多位数组
```cpp
//定义一个指针，指向int a[10]的首地址
int *p1 = a;
//定义一个指针，指向int b[5][6]的首地址
int (*p2)[6] = b;  //表示去b中一次读取6个大小，以块的方式读取，每行是6列
```
总结：

```cpp
int *p1[5];  //表示每次读取int*的大小，一个一个读取，读取5次
int (*p2)[5];//表示每次读取5个int的大小，一块一块的读取
```
---
### 10 结构体
效率：希望牺牲一点空间换取时间的效率

```cpp
struct abc{
    char a;
    short e;
    int b;
};

struct xxx{
    char a;
    int b;
    short e;
};
int main(){
    struct abc buf1;
    struct xxx buf2;
    sizeof(buf1);  //8
    sizeof(buf2);  //12
}
```
---
### 11 内存分布图
[drawio](iNzSrzDgU_-RircgbA2xA-VJ1twoetsMjy1O0HCzRIE.svg)

（1）堆空间

分配：malloc()一旦车弄，返回分配好的地址给我们，只需要接受，对于这个新地址的读法，由程序员灵活操作。输入参数指定分配的大小，单位是B。

释放：free();

```cpp
char *p;
p = (char*)malloc(100);
free(p);
```
---
### 12 函数
一堆代码的集合，用一个标签去描述它。（复用化）

三要素：函数名、输入参数、返回值

#### （1）函数名
```cpp
int main(){
    int (*myshow)(const char *,...);
    printf("hello\n");
    myshow = printf;

    //假如printf函数的地址为0x8048320，那如下的操作等同于上面
    myshow = (int (*)(const char *,...))0x8048320; //强转
    myshow("==========\n");
}
```
实例：假如星期一到星期天，每天要做不同的事。

```cpp
//定义一个存放函数地址的数组
int(*p[7])(int,int);
//给函数数组赋值==赋予函数地址
p[0] = func1;
p[1] = func2;
...
p[6] = func7;
//每天调用
p[day]();
```
#### （2）输入参数
调用者：函数名(要传递的数据)   --实参

被调者：函数的具体实现    函数返回值 函数名(接收的数据){...}  --形参

传递的形式：拷贝==按位复制（值传递、地址传递、连续空间的传递）

重点：连续空间的传递 -- 地址传递

```cpp
//1、数组
//数组名--标签
int nums[10];
//实参
func(nums);
//形参
void func(int *p){...}

//2、结构体
//结构体变量
struct abc{int a;int b;int c};
struct abc buf;
//形参
void func1(struct abc a1){...}
void func2(struct abc *a2){..}
//实参
func1(buf);
func2(&buf); //推荐这种
```
连续空间的只读性：

```cpp
const char *p;  //只读空间
char *p;        //该空间可能修改
```
遇到 fun(char \*p)的标准操作：

```cpp
void fun(char *p){
    int i = 0;
    while(p[i] == 0){
        //p[i]操作
        i++;
    }
}
```
字符空间与非字符空间

```cpp
//字符空间标准模板
int strlen(const char *p){
    int i = 0;
    //错误处理，判断输入参数的合法性
    if(p == NULL){
        //return ...;
    }
    //内存处理，从头到尾逐一处理
    while(p[i]){
        //处理
        i++;
    }
}

//非字符空间标准模板
int *p    unsinged char *p     short *p    struct abc *p
//结束标志：数量 len
void fun(unsiged char *p,int len){
    //执行操作
    int i;
    for(i = 0; i < len; i++){
        //p[i] = ;
    }
}

//特别注意：
//void* :数据空间的标识符
memcpy(void *dest,const void *src,size_t n);
```
区别值的修改与空间的修改

```cpp
//值修改
void func(int *p); //long*  short*  ...
//空间修改
void func(void *p);
```
#### （3）返回值
返回值从return进行拷贝

返回类型：基本数据、指针类型（空间）

指针作为空间返回的唯一数据类型

```cpp
int *func();
//地址：指向的合法性
//作为函数的设计者，必须保证函数返回的地址所指向的空间时合法的【不是局部变量】
```
